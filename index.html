<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Crab Runner</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: monospace;
            color: #535353;
        }
        canvas {
            border: 1px solid #d9d9d9;
            background: #f7f7f7;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 14px;
            color: #535353;
        }
        .score {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 18px;
            font-weight: bold;
            color: #535353;
        }
    </style>
</head>
<body>
    <div class="controls">SPACE: Jump | DOWN: Duck</div>
    <div class="score" id="score">00000</div>
    <canvas id="gameCanvas" width="600" height="150"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');

        // Disable anti-aliasing for crisp pixels
        ctx.imageSmoothingEnabled = false;

        let gameSpeed = 2;
        let score = 0;
        let gameRunning = true;
        let obstacles = [];
        let lastObstacle = 0;
        let frameCount = 0;
        let timeAlive = 0;

        // Crab character
        const crab = {
            x: 50,
            y: 0,
            width: 24,
            height: 16,
            velocityY: 0,
            grounded: true,
            ducking: false,
            legFrame: 0
        };

        const ground = canvas.height - 20;
        crab.y = ground - crab.height;

        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') {
                e.preventDefault();
                if (crab.grounded && gameRunning) {
                    crab.velocityY = -7;
                    crab.grounded = false;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            if (e.code === 'KeyR' && !gameRunning) {
                resetGame();
            }
        });

        // Obstacle class
        class Obstacle {
            constructor(x, type) {
                this.x = x;
                this.type = type;
                this.animFrame = 0;
                
                if (type === 'sandcastle') {
                    this.width = 24;
                    this.height = 28;
                    this.y = ground - this.height;
                } else if (type === 'seagull') {
                    this.width = 20;
                    this.height = 12;
                    this.y = 60 + Math.random() * 15; // Lower down, more reachable
                }
            }

            update() {
                this.x -= gameSpeed;
                this.animFrame++;
            }

            draw() {
                ctx.fillStyle = '#535353';
                
                if (this.type === 'sandcastle') {
                    // Clean silhouette sandcastle like the reference images
                    
                    // Main castle body - solid black
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(this.x + 3, this.y + 20, 18, 8);
                    ctx.fillRect(this.x + 4, this.y + 18, 16, 2);
                    ctx.fillRect(this.x + 5, this.y + 16, 14, 2);
                    
                    // Center tower
                    ctx.fillRect(this.x + 8, this.y + 12, 8, 4);
                    ctx.fillRect(this.x + 9, this.y + 10, 6, 2);
                    
                    // Flag pole and flag
                    ctx.fillRect(this.x + 11, this.y + 8, 1, 3);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(this.x + 12, this.y + 8, 2, 2);
                    
                    // Cut out white details for silhouette effect
                    ctx.fillStyle = '#ffffff';
                    // Door (arched entrance)
                    ctx.fillRect(this.x + 10, this.y + 26, 4, 2);
                    // Windows on main body
                    ctx.fillRect(this.x + 6, this.y + 22, 2, 2);
                    ctx.fillRect(this.x + 16, this.y + 22, 2, 2);
                    // Window on center tower
                    ctx.fillRect(this.x + 10, this.y + 13, 2, 2);
                    // Crenellations (the classic up-down battlements)
                    ctx.fillRect(this.x + 5, this.y + 27, 2, 1);
                    ctx.fillRect(this.x + 9, this.y + 27, 2, 1);
                    ctx.fillRect(this.x + 13, this.y + 27, 2, 1);
                    ctx.fillRect(this.x + 17, this.y + 27, 2, 1);
                    // Tower crenellations
                    ctx.fillRect(this.x + 9, this.y + 11, 2, 1);
                    ctx.fillRect(this.x + 13, this.y + 11, 2, 1);
                    

                    

                    
                } else if (this.type === 'seagull') {
                    // Seagull - white with black outline
                    const wingUp = Math.floor(this.animFrame / 8) % 2;
                    
                    // Fill with white first
                    ctx.fillStyle = '#ffffff';
                    
                    // Body fill
                    ctx.fillRect(this.x + 9, this.y + 9, 6, 3);
                    
                    // Head fill
                    ctx.fillRect(this.x + 15, this.y + 7, 2, 2);
                    
                    // Wings fill
                    if (wingUp) {
                        // Wings up
                        ctx.fillRect(this.x + 5, this.y + 5, 6, 2);
                        ctx.fillRect(this.x + 13, this.y + 5, 6, 2);
                    } else {
                        // Wings down
                        ctx.fillRect(this.x + 5, this.y + 9, 6, 2);
                        ctx.fillRect(this.x + 13, this.y + 9, 6, 2);
                    }
                    
                    // Black outline
                    ctx.fillStyle = '#535353';
                    
                    // Body outline
                    ctx.fillRect(this.x + 8, this.y + 8, 8, 1); // top
                    ctx.fillRect(this.x + 8, this.y + 12, 8, 1); // bottom
                    ctx.fillRect(this.x + 8, this.y + 8, 1, 5); // left
                    ctx.fillRect(this.x + 15, this.y + 8, 1, 5); // right
                    
                    // Head outline
                    ctx.fillRect(this.x + 14, this.y + 6, 4, 1); // top
                    ctx.fillRect(this.x + 14, this.y + 9, 4, 1); // bottom
                    ctx.fillRect(this.x + 14, this.y + 6, 1, 4); // left
                    ctx.fillRect(this.x + 17, this.y + 6, 1, 4); // right
                    
                    // Beak
                    ctx.fillRect(this.x + 18, this.y + 7, 2, 2);
                    
                    // Wings outline
                    if (wingUp) {
                        // Wings up
                        ctx.fillRect(this.x + 4, this.y + 4, 8, 1); // left wing top
                        ctx.fillRect(this.x + 4, this.y + 7, 8, 1); // left wing bottom
                        ctx.fillRect(this.x + 4, this.y + 4, 1, 4); // left wing left
                        ctx.fillRect(this.x + 11, this.y + 4, 1, 4); // left wing right
                        
                        ctx.fillRect(this.x + 12, this.y + 4, 8, 1); // right wing top
                        ctx.fillRect(this.x + 12, this.y + 7, 8, 1); // right wing bottom
                        ctx.fillRect(this.x + 12, this.y + 4, 1, 4); // right wing left
                        ctx.fillRect(this.x + 19, this.y + 4, 1, 4); // right wing right
                    } else {
                        // Wings down
                        ctx.fillRect(this.x + 4, this.y + 8, 8, 1); // left wing top
                        ctx.fillRect(this.x + 4, this.y + 11, 8, 1); // left wing bottom
                        ctx.fillRect(this.x + 4, this.y + 8, 1, 4); // left wing left
                        ctx.fillRect(this.x + 11, this.y + 8, 1, 4); // left wing right
                        
                        ctx.fillRect(this.x + 12, this.y + 8, 8, 1); // right wing top
                        ctx.fillRect(this.x + 12, this.y + 11, 8, 1); // right wing bottom
                        ctx.fillRect(this.x + 12, this.y + 8, 1, 4); // right wing left
                        ctx.fillRect(this.x + 19, this.y + 8, 1, 4); // right wing right
                    }
                }
            }

            collidesWith(crab) {
                // Get crab collision mask
                const crabMask = this.getCrabCollisionMask(crab);
                const obstacleMask = this.getObstacleCollisionMask();
                
                // Check for pixel-perfect collision
                return this.checkPixelCollision(crabMask, obstacleMask, crab);
            }
            
            getCrabCollisionMask(crab) {
                const mask = [];
                const crabHeight = crab.ducking ? 8 : crab.height;
                const crabY = crab.ducking ? crab.y + 8 : crab.y;
                
                if (crab.ducking) {
                    // Ducking crab mask - only the body, not the pincers
                    for (let y = 0; y < 6; y++) {
                        mask[y] = [];
                        for (let x = 0; x < 16; x++) {
                            // Only the main body is solid (x: 4-19, y: 0-5)
                            mask[y][x] = (x >= 4 && x < 20);
                        }
                    }
                } else {
                    // Normal crab mask - only the body, not the pincers or eyes
                    for (let y = 0; y < crab.height; y++) {
                        mask[y] = [];
                        for (let x = 0; x < 24; x++) {
                            // Main body is solid (x: 6-17, y: 2-11)
                            let isSolid = (x >= 6 && x < 18 && y >= 2 && y < 12);
                            
                            // Shell pattern details are also solid
                            if (y >= 4 && y < 6) {
                                if ((x >= 8 && x < 10) || (x >= 14 && x < 16) || (x >= 11 && x < 13 && y === 6)) {
                                    isSolid = true;
                                }
                            }
                            
                            mask[y][x] = isSolid;
                        }
                    }
                }
                
                return {
                    mask: mask,
                    x: crab.x,
                    y: crabY,
                    width: 24,
                    height: crabHeight
                };
            }
            
            getObstacleCollisionMask() {
                const mask = [];
                
                if (this.type === 'sandcastle') {
                    // Sandcastle mask - only the black parts are solid
                    for (let y = 0; y < this.height; y++) {
                        mask[y] = [];
                        for (let x = 0; x < this.width; x++) {
                            let isSolid = false;
                            
                            // Main castle body (black parts)
                            if (y >= 20 && y < 28 && x >= 3 && x < 21) {
                                isSolid = true;
                            }
                            if (y >= 18 && y < 20 && x >= 4 && x < 20) {
                                isSolid = true;
                            }
                            if (y >= 16 && y < 18 && x >= 5 && x < 19) {
                                isSolid = true;
                            }
                            
                            // Center tower
                            if (y >= 12 && y < 16 && x >= 8 && x < 16) {
                                isSolid = true;
                            }
                            if (y >= 10 && y < 12 && x >= 9 && x < 15) {
                                isSolid = true;
                            }
                            
                            // Flag pole
                            if (y >= 8 && y < 11 && x >= 11 && x < 12) {
                                isSolid = true;
                            }
                            
                            // Cut out white details (door, windows, crenellations)
                            if (y >= 26 && y < 28 && x >= 10 && x < 14) { // Door
                                isSolid = false;
                            }
                            if (y >= 22 && y < 24 && (x >= 6 && x < 8 || x >= 16 && x < 18)) { // Windows
                                isSolid = false;
                            }
                            if (y >= 13 && y < 15 && x >= 10 && x < 12) { // Tower window
                                isSolid = false;
                            }
                            if (y === 27 && (x >= 5 && x < 7 || x >= 9 && x < 11 || x >= 13 && x < 15 || x >= 17 && x < 19)) { // Crenellations
                                isSolid = false;
                            }
                            if (y === 11 && (x >= 9 && x < 11 || x >= 13 && x < 15)) { // Tower crenellations
                                isSolid = false;
                            }
                            
                            mask[y][x] = isSolid;
                        }
                    }
                } else if (this.type === 'seagull') {
                    // Seagull mask - only the black outline and beak are solid
                    const wingUp = Math.floor(this.animFrame / 8) % 2;
                    
                    for (let y = 0; y < this.height; y++) {
                        mask[y] = [];
                        for (let x = 0; x < this.width; x++) {
                            let isSolid = false;
                            
                            // Body outline
                            if (y === 8 && x >= 8 && x < 16) isSolid = true;
                            if (y === 12 && x >= 8 && x < 16) isSolid = true;
                            if (x === 8 && y >= 8 && y < 13) isSolid = true;
                            if (x === 15 && y >= 8 && y < 13) isSolid = true;
                            
                            // Head outline
                            if (y === 6 && x >= 14 && x < 18) isSolid = true;
                            if (y === 9 && x >= 14 && x < 18) isSolid = true;
                            if (x === 14 && y >= 6 && y < 10) isSolid = true;
                            if (x === 17 && y >= 6 && y < 10) isSolid = true;
                            
                            // Beak
                            if (y >= 7 && y < 9 && x >= 18 && x < 20) isSolid = true;
                            
                            // Wings outline
                            if (wingUp) {
                                // Wings up
                                if (y === 4 && x >= 4 && x < 12) isSolid = true;
                                if (y === 7 && x >= 4 && x < 12) isSolid = true;
                                if (x === 4 && y >= 4 && y < 8) isSolid = true;
                                if (x === 11 && y >= 4 && y < 8) isSolid = true;
                                
                                if (y === 4 && x >= 12 && x < 20) isSolid = true;
                                if (y === 7 && x >= 12 && x < 20) isSolid = true;
                                if (x === 12 && y >= 4 && y < 8) isSolid = true;
                                if (x === 19 && y >= 4 && y < 8) isSolid = true;
                            } else {
                                // Wings down
                                if (y === 8 && x >= 4 && x < 12) isSolid = true;
                                if (y === 11 && x >= 4 && x < 12) isSolid = true;
                                if (x === 4 && y >= 8 && y < 12) isSolid = true;
                                if (x === 11 && y >= 8 && y < 12) isSolid = true;
                                
                                if (y === 8 && x >= 12 && x < 20) isSolid = true;
                                if (y === 11 && x >= 12 && x < 20) isSolid = true;
                                if (x === 12 && y >= 8 && y < 12) isSolid = true;
                                if (x === 19 && y >= 8 && y < 12) isSolid = true;
                            }
                            
                            mask[y][x] = isSolid;
                        }
                    }
                }
                
                return {
                    mask: mask,
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
            
            checkPixelCollision(crabMask, obstacleMask, crab) {
                // First do a quick bounding box check
                if (crabMask.x + crabMask.width < obstacleMask.x || 
                    crabMask.x > obstacleMask.x + obstacleMask.width ||
                    crabMask.y + crabMask.height < obstacleMask.y || 
                    crabMask.y > obstacleMask.y + obstacleMask.height) {
                    return false;
                }
                
                // Calculate overlap area
                const overlapX1 = Math.max(crabMask.x, obstacleMask.x);
                const overlapY1 = Math.max(crabMask.y, obstacleMask.y);
                const overlapX2 = Math.min(crabMask.x + crabMask.width, obstacleMask.x + obstacleMask.width);
                const overlapY2 = Math.min(crabMask.y + crabMask.height, obstacleMask.y + obstacleMask.height);
                
                // Check each pixel in the overlap area
                for (let y = overlapY1; y < overlapY2; y++) {
                    for (let x = overlapX1; x < overlapX2; x++) {
                        // Convert world coordinates to mask coordinates
                        const crabMaskX = x - crabMask.x;
                        const crabMaskY = y - crabMask.y;
                        const obstacleMaskX = x - obstacleMask.x;
                        const obstacleMaskY = y - obstacleMask.y;
                        
                        // Check if both masks have solid pixels at this position
                        if (crabMaskX >= 0 && crabMaskX < crabMask.width &&
                            crabMaskY >= 0 && crabMaskY < crabMask.height &&
                            obstacleMaskX >= 0 && obstacleMaskX < obstacleMask.width &&
                            obstacleMaskY >= 0 && obstacleMaskY < obstacleMask.height) {
                            
                            if (crabMask.mask[crabMaskY] && crabMask.mask[crabMaskY][crabMaskX] &&
                                obstacleMask.mask[obstacleMaskY] && obstacleMask.mask[obstacleMaskY][obstacleMaskX]) {
                                return true; // Pixel-perfect collision detected!
                            }
                        }
                    }
                }
                
                return false;
            }
        }

        function spawnObstacle() {
            // Beach-themed obstacles with varied frequencies
            const rand = Math.random();
            let type;
            if (rand < 0.8) {
                type = 'sandcastle'; // 80% chance
            } else {
                type = 'seagull'; // 20% chance
            }
            obstacles.push(new Obstacle(canvas.width, type));
        }

        function updateCrab() {
            frameCount++;
            
            // Duck logic
            crab.ducking = keys['ArrowDown'] || keys['KeyS'];
            
            // Gravity
            if (!crab.grounded) {
                crab.velocityY += 0.3;
                crab.y += crab.velocityY;
            }

            // Ground collision
            if (crab.y >= ground - crab.height) {
                crab.y = ground - crab.height;
                crab.velocityY = 0;
                crab.grounded = true;
            }

            // Leg animation
            if (crab.grounded && frameCount % 8 === 0) {
                crab.legFrame = (crab.legFrame + 1) % 4;
            }
        }

        function drawCrab() {
            ctx.fillStyle = '#535353';
            
            const height = crab.ducking ? 8 : crab.height;
            const y = crab.ducking ? crab.y + 8 : crab.y;
            
            if (crab.ducking) {
                // Ducking crab - flat and wide
                ctx.fillRect(crab.x + 4, y, 16, 6);
                // Eyes on stalks (shorter when ducking)
                ctx.fillRect(crab.x + 6, y - 2, 2, 2);
                ctx.fillRect(crab.x + 16, y - 2, 2, 2);
                // Eyes
                ctx.fillRect(crab.x + 6, y - 4, 2, 2);
                ctx.fillRect(crab.x + 16, y - 4, 2, 2);
                // Pincers spread wide with proper gaps
                // Left pincer
                ctx.fillRect(crab.x - 2, y + 1, 6, 3);
                ctx.fillRect(crab.x - 2, y, 2, 2); // upper claw
                ctx.fillRect(crab.x + 1, y + 4, 2, 2); // lower claw (gap in between)
                // Right pincer
                ctx.fillRect(crab.x + 20, y + 1, 6, 3);
                ctx.fillRect(crab.x + 24, y, 2, 2); // upper claw
                ctx.fillRect(crab.x + 21, y + 4, 2, 2); // lower claw (gap in between)
            } else {
                // Normal crab body - more crab-like shape
                ctx.fillRect(crab.x + 6, y + 2, 12, 10);
                
                // Eyes on stalks
                ctx.fillRect(crab.x + 8, y - 4, 2, 6);
                ctx.fillRect(crab.x + 14, y - 4, 2, 6);
                // Eye balls
                ctx.fillRect(crab.x + 8, y - 6, 2, 2);
                ctx.fillRect(crab.x + 14, y - 6, 2, 2);
                
                // Big prominent pincers with claws and gaps
                const pincerBob = Math.sin(frameCount * 0.1) * 1;
                // Left pincer
                ctx.fillRect(crab.x - 2, y + 3 + pincerBob, 8, 4);
                // Left pincer claws with gap
                ctx.fillRect(crab.x - 2, y + 2 + pincerBob, 3, 2); // upper claw
                ctx.fillRect(crab.x + 1, y + 6 + pincerBob, 3, 2); // lower claw
                // Right pincer  
                ctx.fillRect(crab.x + 18, y + 3 - pincerBob, 8, 4);
                // Right pincer claws with gap
                ctx.fillRect(crab.x + 23, y + 2 - pincerBob, 3, 2); // upper claw
                ctx.fillRect(crab.x + 20, y + 6 - pincerBob, 3, 2); // lower claw
                
                // Shell pattern
                ctx.fillRect(crab.x + 8, y + 4, 2, 2);
                ctx.fillRect(crab.x + 14, y + 4, 2, 2);
                ctx.fillRect(crab.x + 11, y + 6, 2, 2);
                
                // Animated legs - more crab-like
                const legOffset = crab.legFrame < 2 ? 0 : 1;
                for (let i = 0; i < 4; i++) {
                    const legY = y + 12 + (i % 2 === legOffset ? 1 : 0);
                    ctx.fillRect(crab.x + 7 + i * 2, legY, 1, 3);
                    ctx.fillRect(crab.x + 7 + i * 2 + (i % 2 ? 1 : -1), legY + 3, 2, 1);
                }
            }
        }

        function drawGround() {
            ctx.fillStyle = '#535353';
            ctx.fillRect(0, ground, canvas.width, 2);
            
            // Sand texture - only animate if game is running
            if (gameRunning) {
                for (let i = 0; i < canvas.width; i += 8) {
                    if (Math.random() > 0.7) {
                        ctx.fillRect(i, ground + 2, 2, 2);
                    }
                }
            } else {
                // Static sand when dead
                for (let i = 0; i < canvas.width; i += 16) {
                    ctx.fillRect(i, ground + 2, 2, 2);
                    ctx.fillRect(i + 8, ground + 4, 2, 2);
                }
            }
            
            // Add shells scattered in the sand - more visible and varied
            const shellOffset = gameRunning ? (score % 400) : 0;
            
            // Shell 1 - clam shell (larger, more visible)
            ctx.fillStyle = '#d0d0d0';
            ctx.fillRect(80 - shellOffset, ground + 2, 8, 4);
            ctx.fillRect(82 - shellOffset, ground + 1, 4, 6);
            ctx.fillStyle = '#535353';
            ctx.fillRect(83 - shellOffset, ground + 2, 2, 4);
            
            // Shell 2 - spiral shell
            ctx.fillStyle = '#d0d0d0';
            ctx.fillRect(250 - (score % 350), ground + 3, 6, 3);
            ctx.fillRect(252 - (score % 350), ground + 2, 2, 5);
            ctx.fillStyle = '#535353';
            ctx.fillRect(253 - (score % 350), ground + 3, 1, 3);
            
            // Shell 3 - scallop shell
            ctx.fillStyle = '#d0d0d0';
            ctx.fillRect(420 - (score % 380), ground + 2, 7, 4);
            ctx.fillRect(422 - (score % 380), ground + 1, 3, 6);
            ctx.fillStyle = '#535353';
            ctx.fillRect(423 - (score % 380), ground + 2, 1, 4);
            
            // Shell 4 - small clam
            ctx.fillStyle = '#d0d0d0';
            ctx.fillRect(580 - (score % 420), ground + 3, 5, 3);
            ctx.fillRect(581 - (score % 420), ground + 2, 3, 5);
            ctx.fillStyle = '#535353';
            ctx.fillRect(582 - (score % 420), ground + 3, 1, 3);
            
            // Shell 5 - extra shell for more variety
            ctx.fillStyle = '#d0d0d0';
            ctx.fillRect(150 - (score % 300), ground + 4, 4, 2);
            ctx.fillRect(151 - (score % 300), ground + 3, 2, 4);
            ctx.fillStyle = '#535353';
            ctx.fillRect(152 - (score % 300), ground + 4, 1, 2);
        }

        function drawClouds() {
            ctx.fillStyle = '#d0d0d0';
            // Static clouds for background
            const cloudOffset = gameRunning ? (score % 200) : 0;
            ctx.fillRect(100 - cloudOffset, 20, 24, 8);
            ctx.fillRect(300 - (score % 300), 30, 32, 8);
            ctx.fillRect(500 - (score % 250), 15, 20, 8);
            
            // More clouds
            ctx.fillRect(150 - (score % 180), 25, 16, 6);
            ctx.fillRect(400 - (score % 220), 18, 28, 10);
        }

        function drawSun() {
            // Day/night cycle - full cycle takes 7200 frames (2 minutes at 60fps)
            const cycleProgress = (frameCount % 7200) / 7200;
            
            // Sun position - arcs from east (right) to west (left)
            let sunX, sunY;
            if (cycleProgress < 0.5) {
                // Day phase (0 to 0.5) - sun rises and sets
                const dayProgress = cycleProgress * 2; // 0 to 1
                sunX = canvas.width - (dayProgress * canvas.width * 1.2) + 30; // Start from right, go left
                sunY = 40 - Math.sin(dayProgress * Math.PI) * 30; // Higher arc, less dramatic
            } else {
                // Night phase (0.5 to 1) - sun is below horizon
                sunX = -50; // Off screen to the left
                sunY = 150; // Below ground
            }
            
            // Only draw sun during day
            if (cycleProgress < 0.5) {
                ctx.fillStyle = '#d0d0d0';
                // Main sun body - more circular
                ctx.fillRect(sunX + 4, sunY + 4, 8, 8);
                ctx.fillRect(sunX + 2, sunY + 6, 12, 4);
                ctx.fillRect(sunX + 6, sunY + 2, 4, 12);
                
                // Sun rays - more prominent
                ctx.fillRect(sunX - 2, sunY + 6, 4, 4);
                ctx.fillRect(sunX + 14, sunY + 6, 4, 4);
                ctx.fillRect(sunX + 6, sunY - 2, 4, 4);
                ctx.fillRect(sunX + 6, sunY + 14, 4, 4);
                
                // Diagonal rays
                ctx.fillRect(sunX + 2, sunY + 2, 3, 3);
                ctx.fillRect(sunX + 11, sunY + 2, 3, 3);
                ctx.fillRect(sunX + 2, sunY + 11, 3, 3);
                ctx.fillRect(sunX + 11, sunY + 11, 3, 3);
            }
        }

        function drawMoon() {
            // Day/night cycle - full cycle takes 7200 frames (2 minutes at 60fps)
            const cycleProgress = (frameCount % 7200) / 7200;
            
            // Moon position - arcs from east (right) to west (left) during night
            if (cycleProgress > 0.5) {
                const nightProgress = (cycleProgress - 0.5) * 2; // 0 to 1 during night
                const moonX = canvas.width - (nightProgress * canvas.width * 1.2) + 30;
                const moonY = 40 - Math.sin(nightProgress * Math.PI) * 30; // Same arc as sun
                
                // Simple triangle moon - no glow, just the triangle (enlarged by 15%)
                ctx.fillStyle = '#ffffff'; // Bright white
                
                // Triangle shape pointing right (like |>) - scaled up by 15%
                ctx.fillRect(moonX + 3, moonY + 7, 9, 2);
                ctx.fillRect(moonX + 5, moonY + 9, 7, 2);
                ctx.fillRect(moonX + 7, moonY + 11, 5, 2);
                ctx.fillRect(moonX + 9, moonY + 13, 3, 2);
                ctx.fillRect(moonX + 5, moonY + 15, 7, 2);
                ctx.fillRect(moonX + 3, moonY + 17, 9, 2);
                
                // Moon craters for detail and visibility - scaled up by 15%
                ctx.fillStyle = '#e0e0e0';
                ctx.fillRect(moonX + 7, moonY + 7, 3, 3);
                ctx.fillRect(moonX + 15, moonY + 11, 2, 2);
                ctx.fillRect(moonX + 11, moonY + 17, 2, 2);
            }
        }

        function updateGame() {
            if (!gameRunning) return;

            frameCount++;
            timeAlive = Math.floor(frameCount / 60); // Assuming 60fps
            score = timeAlive; // Score is time survived
            scoreEl.textContent = score.toString().padStart(5, '0');
            
            // Increase speed gradually every second (60 frames)
            if (frameCount % 60 === 0) {
                gameSpeed += 0.1;
            }

            updateCrab();

            // Spawn obstacles - start very sparse like Chrome dino
            const obstacleFrequency = Math.max(300 - Math.floor(timeAlive / 15) * 20, 120);
            if (frameCount - lastObstacle > obstacleFrequency + Math.random() * 180) {
                spawnObstacle();
                lastObstacle = frameCount;
            }

            // Update obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].update();
                
                if (obstacles[i].collidesWith(crab)) {
                    console.log('Game Over! Hit by:', obstacles[i].type, 'at position:', obstacles[i].x, obstacles[i].y);
                    gameRunning = false;
                    break;
                }
                
                if (obstacles[i].x + obstacles[i].width < 0) {
                    obstacles.splice(i, 1);
                }
            }
        }

        function draw() {
            // Clear with white background
            ctx.fillStyle = '#f7f7f7';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawClouds();
            drawSun();
            drawGround();
            drawCrab();
            
            obstacles.forEach(obstacle => obstacle.draw());
            
            // Day/night gradient overlay - pixelated dithering effect (top 25% only)
            const cycleProgress = (frameCount % 7200) / 7200;
            const ditherHeight = Math.floor(canvas.height * 0.25); // Top 25% of screen
            
            if (cycleProgress > 0.5) {
                // Night phase - pixelated gradient in top 25% only
                const nightProgress = (cycleProgress - 0.5) * 2; // 0 to 1 during night
                const intensity = Math.min(nightProgress * 0.4, 0.4); // Max 40% coverage
                
                // Create pixelated dithering pattern only in top portion
                for (let y = 0; y < ditherHeight; y++) {
                    const gradientProgress = y / ditherHeight;
                    const coverage = intensity * (1 - gradientProgress * 0.8); // Fade to white by 80% down
                    
                    if (coverage > 0) {
                        ctx.fillStyle = '#535353';
                        // Dithering pattern - deterministic checkerboard
                        for (let x = 0; x < canvas.width; x += 4) {
                            for (let y2 = y; y2 < y + 4; y2 += 4) {
                                // Use deterministic pattern based on position
                                const patternValue = ((x + y2) % 8) / 8;
                                if (patternValue < coverage) {
                                    ctx.fillRect(x, y2, 2, 2);
                                }
                                if ((patternValue + 0.5) % 1 < coverage) {
                                    ctx.fillRect(x + 2, y2 + 2, 2, 2);
                                }
                            }
                        }
                    }
                }
            } else if (cycleProgress < 0.1) {
                // Dawn phase - pixelated fade from grey to light
                const dawnProgress = cycleProgress * 10; // 0 to 1 during dawn
                const intensity = (1 - dawnProgress) * 0.4; // Fade from 40% to 0% coverage
                
                if (intensity > 0) {
                    ctx.fillStyle = '#535353';
                    for (let y = 0; y < ditherHeight; y++) {
                        const gradientProgress = y / ditherHeight;
                        const coverage = intensity * (1 - gradientProgress * 0.8);
                        
                        if (coverage > 0) {
                            for (let x = 0; x < canvas.width; x += 4) {
                                for (let y2 = y; y2 < y + 4; y2 += 4) {
                                    const patternValue = ((x + y2) % 8) / 8;
                                    if (patternValue < coverage) {
                                        ctx.fillRect(x, y2, 2, 2);
                                    }
                                    if ((patternValue + 0.5) % 1 < coverage) {
                                        ctx.fillRect(x + 2, y2 + 2, 2, 2);
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (cycleProgress > 0.4) {
                // Dusk phase - pixelated fade from light to grey
                const duskProgress = (cycleProgress - 0.4) * 10; // 0 to 1 during dusk
                const intensity = duskProgress * 0.4; // Fade from 0% to 40% coverage
                
                if (intensity > 0) {
                    ctx.fillStyle = '#535353';
                    for (let y = 0; y < ditherHeight; y++) {
                        const gradientProgress = y / ditherHeight;
                        const coverage = intensity * (1 - gradientProgress * 0.8);
                        
                        if (coverage > 0) {
                            for (let x = 0; x < canvas.width; x += 4) {
                                for (let y2 = y; y2 < y + 4; y2 += 4) {
                                    const patternValue = ((x + y2) % 8) / 8;
                                    if (patternValue < coverage) {
                                        ctx.fillRect(x, y2, 2, 2);
                                    }
                                    if ((patternValue + 0.5) % 1 < coverage) {
                                        ctx.fillRect(x + 2, y2 + 2, 2, 2);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Draw moon AFTER all dithering so it appears on top
            drawMoon();
            
            if (!gameRunning) {
                // Draw opaque background for game over text
                ctx.fillStyle = 'rgba(247, 247, 247, 0.9)'; // Semi-transparent white
                ctx.fillRect(canvas.width/2 - 100, canvas.height/2 - 35, 200, 70);
                
                // Draw border around the background
                ctx.strokeStyle = '#535353';
                ctx.lineWidth = 2;
                ctx.strokeRect(canvas.width/2 - 100, canvas.height/2 - 35, 200, 70);
                
                // Draw game over text
                ctx.fillStyle = '#535353';
                ctx.font = '16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('G A M E  O V E R', canvas.width/2, canvas.height/2 - 10);
                ctx.font = '12px monospace';
                ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 10);
            }
        }

        function resetGame() {
            crab.y = ground - crab.height;
            crab.velocityY = 0;
            crab.grounded = true;
            crab.ducking = false;
            crab.legFrame = 0;
            obstacles = [];
            score = 0;
            timeAlive = 0;
            gameSpeed = 2;
            lastObstacle = 0;
            frameCount = 0;
            gameRunning = true;
            scoreEl.textContent = '00000';
        }

        function gameLoop() {
            updateGame();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        gameLoop();
    </script>
</body>
</html>
